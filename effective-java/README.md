# Effective Java

> These are my notes from the *Effective Java Third Edition* book by *Joshua Bloch*.

* [Creating and Destroying Objects](c1)
  * [1: Consider static factory methods instead of constructors](1)
  * [2: Consider a builder when faced with many constructor parameters](2)
  * [3: Enforce the singleton property with a private constructor or an enum type](3)
  * [4: Enforce noninstantiability with a private constructor](4)
  * [5: Prefer dependency injection to hardwiring resources](5)
  * [6: Avoid creating unnecessary objects](6)
  * [7: Eliminate obsolete object references](7)
  * [8: Avoid finalizers and cleaners](8)
  * [9: Prefer try-wioth-resources to try-finally](9)
* [Methods Common to All Objects](c2)
  * [10: Obey the general contract when overriding `equals`](10)
  * [11: Always override `hashCode` when you override `equals`](11)
  * [12: Always override `toString`](12) 
  * [13: Override `clone` judiciously](13)
  * [14: Consider implementing `Comparable`](14)
* [Classes and Interfaces](c3)
  * [15: Minimize the accessibility of classes and members](15)
  * [16: In public classes, use accessor methods, not public fields](16)
  * [17: Minimize mutability](17)
  * [18: Favor composition over inheritance](18)
  * [19: Design and document for inheritance or else prohibit it](19)
  * [20: Prefer interfaces to abstract classes](20)
  * [21: Design interfaces for posterity](21)  
  * [22: Use interfaces only to define types](22)
  * [23: Prefer class hierarchies to tagged classes](23)
  * [24: Favor static members classes over nonstatic](24)
  * [25: Limit source files to a single top-level class](25)
* [Generics](c4)
  * [26: Don't use raw types](26)
  * [27: Eliminate unchecked warnings](27)
  * [28: Prefer lists to arrays](28)
  * [29: Favor generic types](29)
  * [30: Favor generic methods](30)
  * [31: Use bounded wildcards to increase API flexibility](31)
  * [32: Combine generics and varargs judiciously](32)
  * [33: Consider typesafe heterogeneous containers](33)
* [Enums and Annotations](c5)
  * [34: Use enums instead of `int` constants](34)
  * [35: Use instance fields instead of ordinals](35)
  * [36: Use `EnumSet` instead of bit fields](36)
  * [37: Use `EnumMap` instead of ordinal indexing](37)
  * [38: Emulate extensible enums with interfaces](38)
  * [39: Prefer annotations to naming patterns](39)
  * [40: Consistently use the `Override` annotation](40)
  * [41: Use marker interfaces to define types](41)
* [Lambdas and Streams](c6)
  * [42: Prefer lambdas to anonymous classes](42)
  * [43 Prefer method references to lambdas](43)
  * [44: Favor the use of standard functional interfaces](44)
  * [45: Use streams judiciously](45)
  * [46: Prefer side-effect-free functions in streams](46)
  * [47: Prefer Collection to Stream as a return type](47)
  * [48: Use caution when making streams parallel](48)
* [Methods](c7)
  * [49: Check parameters for validity](49)
  * [50: Make defensive copies when needed](50)
  * [51: Design method signatures carefully](51)
  * [52: Use overloading judiciously](52)
  * [53: Use varargs judiciously](53)
  * [54: Return empty collections or arrays, not nulls](54)
  * [55: Return optionals judiciously](55)
  * [56: Write doc comments for all exposed API elements](56)
* [General Programming](c8)
  * [57: Minimize the scope of local variables](57)
  * [58: Prefer for-each loops to traditional `for` loops](58)
  * [59: Know and use the libraries](59)
